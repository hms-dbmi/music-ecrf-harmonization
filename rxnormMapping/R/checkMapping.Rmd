---
title: "Check RXNORM Mapping"
author: "Simran Makwana"
date: "10/13/2021"
output: html_document
---

Libraries
```{r}
rm(list=ls())
library(tidyverse)
library(VennDiagram)
```

create table meds_concepts as
```select * from concept_dimension where concept_cd like 'HOMEMED:%' or concept_cd like 'ADMINMED:%';```
create table umls_meds_subset as 
```select * from mrconso where sab = 'RXNORM' or sab = 'MMSL';```

Read in files
```{r}
allMeds <- read.delim("../data/allMeds.dsv")

umlsMultumRxnorm <- read.delim("../data/umlsMeds.dsv")
```

Extract MULTUM code
Note that the MULTUM code is located before the HOMEMED/ADMINMED code in the BCH concept path.
It often starts with a 'd', but not always.
```{r}

allMeds <- allMeds %>%
  mutate(MULTUM = sapply(strsplit(as.character(allMeds$CONCEPT_PATH), split = '[\\]'), function(x) x[length(x)-1]),
         firstMultum = substr(MULTUM, 1,1))

# we expect the multum code to begin with the letter 'd', but notice that there are several cases where it does not.
# this may mean that 1) we extracted the wrong code or 2) this code is a MULTUM code in a different format than expected
table(allMeds$firstMultum)

# of the codes which do not start with a 'd', we notice that none of them are in the UMLS MULTUM ontology
print("Are any of the BCH codes which we extracted as MULTUM but do not start with the letter 'd' actually in the UMLS MULTUM ontology?")
any((allMeds %>% 
      filter(firstMultum != 'd') %>% 
      pull(MULTUM) %>% 
      as.numeric()) %in% 
    (umlsMultumRxnorm %>% 
      filter(SAB == 'MMSL', !grepl('d', CODE), CODE != 'NOCODE')  %>% 
      pull(CODE) %>% 
      as.numeric()) 
    ) 

# we also notice that all of the codes which do not start with a 'd' match the BCH concept_cd (sourcesystem id) for that entry
print("Do all of the BCH codes which we extracted as MULTUM but do not start with the letter 'd' match the BCH concept_cd?")
allMeds %>%
  filter(firstMultum != 'd') %>%
  mutate(extracted_multum_equal_bch_concept = MULTUM == SOURCESYSTEM_CD) %>%
  pull(extracted_multum_equal_bch_concept) %>%
  all(. == TRUE)
      
# we also notice that the concept_path is not complete.
print("Is the BCH concept_path incomplete for all BCH codes which we extracted as MULTUM but do not start with the letter 'd'?")
allMeds %>%
  filter(firstMultum != 'd') %>%
  mutate(noncategorized_concept = grepl('Non-Categorized', CONCEPT_PATH)) %>%
  pull(noncategorized_concept) %>%
  all(. == TRUE)

# because of this, we only consider the extracted codes which begin with 'd' to be MULTUM codes, and disregard the rest for now.
allMedsWithMultum <- allMeds %>% filter(firstMultum == 'd') 

```

generate direct mapping from BCH to RXNORM using MULTUM
```{r}
# filter the umls database to only include entries where the multum code is part of the bch database and the ontology is multum
multum <- umlsMultumRxnorm %>% 
  filter( CODE %in% allMedsWithMultum$MULTUM, 
          SAB == "MMSL") %>%
  select( CUI, MULTUM = CODE, MULTUM_STR = STR)

# using the CUIs found in the previous step, link the MULTUM codes to the RXNORM ontology
rxnorm <- umlsMultumRxnorm %>%
  filter( CUI %in% multum$CUI, 
          SAB == "RXNORM") %>%
  select( CUI, RXNORM = CODE, RXNORM_STR = STR )

# combine the MULTUM, CUI, and RXNORM information with the BCH db info
allMedsWithMultumMap <- left_join( allMedsWithMultum, multum, by= "MULTUM")
allMedsWithMultumMap <- left_join( allMedsWithMultumMap, rxnorm, by= "CUI")

```

Compare the direct mapping we made using UMLS with our previously manually generated mapping
```{r}
###compare with our previous mapping
manualMap <- read.csv("../../medications_before_and_after/data/MUSIC Medications_ mapping from eCRF generic names and trades to BCH variables - BCH med concept summary updated 07-20-21.csv")

# we focus on the mapping from BCH to RXNORM and remove the entries where there were multiple RXNORM codes being mapped to the BCH code
manualMap <- unique(manualMap[, c("CONCEPT_CD", "RXNORM_CODES")])
manualMap <- manualMap %>%
  filter( RXNORM_CODES != "greater than 5 RXNORM codes mapped to BCH code") %>%
  mutate(RXNORM_CODES = strsplit(as.character(RXNORM_CODES), ",")) %>% 
  unnest(RXNORM_CODES)

# I'm not 100% sure what this does. I think I cover it later on . Alba?
multumMapSubset <- unique(allMedsWithMultumMap %>%
  filter( CONCEPT_CD %in% manualMap$CONCEPT_CD) %>%
  select( CONCEPT_CD, RXNORM_MULTUMMAP = RXNORM ))

finalCheck <- inner_join( manualMap, multumMapSubset)
finalCheck$diff <- as.numeric(finalCheck$RXNORM_CODES) - as.numeric(finalCheck$RXNORM_MULTUMMAP)


#### check with mohamad mapping file
m_mapping <- read.csv("../data/P00036898_EVENT_CATALOG_SYN_RXNORM_CODES.csv")


# Did I describe this step correctly Alba?
# extract the BCH codes for ADMINMED and HOMEMED from their distinct columns
adminMed <- m_mapping %>%
  mutate( CONCEPT_CD = paste0("ADMINMED:", EVENT_CD), 
          MULTUM_CD = gsub("MUL.ORD!", "", RXNORM_CODE), 
          RXNORM_CD = gsub("RXNORM!", "", RXNORM_DISPLAY)) %>%
  select( CONCEPT_CD,MULTUM_CD, RXNORM_CD, DESCR_CD = DNUM )

homeMed <- m_mapping %>%
  mutate( CONCEPT_CD = paste0("HOMEMED:", SYNONYM_ID), 
          MULTUM_CD = gsub("MUL.ORD!", "", RXNORM_CODE), 
          RXNORM_CD = gsub("RXNORM!", "", RXNORM_DISPLAY)) %>%
  select( CONCEPT_CD,MULTUM_CD, RXNORM_CD, DESCR_CD = DNUM )

mMapping <- unique( rbind( adminMed, homeMed ))
secondCheck <- inner_join( manualMap, mMapping)
secondCheck$diff <- as.numeric(secondCheck$RXNORM_CODES) - as.numeric(secondCheck$RXNORM_CD)
secondCheck$DESCR_CD <- tolower( str_trim( secondCheck$DESCR_CD ) )
secondCheck <- secondCheck[!duplicated( secondCheck), ]

# create dataframe of different source results
compare_mappings <- allMedsWithMultumMap %>%
  select(CONCEPT_CD, SOURCESYSTEM_CD, NAME_CHAR, MULTUM, MULTUM_STR, RXNORM, RXNORM_STR) %>%
  full_join(manualMap, by = 'CONCEPT_CD') %>%
  rename(RXNORM.manual = RXNORM_CODES) %>%
  full_join(mMapping, by = 'CONCEPT_CD') %>%
  rename(RXNORM.mohamad = RXNORM_CD,
         MULTUM.mohamad = MULTUM_CD,
         DESC.mohamad = DESCR_CD) 

# create a subset where we only compare BCH_CD, and RXNORM_CD mapping from each source
compare_mappings_subset <- compare_mappings %>%
  select(CONCEPT_CD, RXNORM, 
         RXNORM.manual, RXNORM.mohamad) %>%
  rename(CONCEPT_CD.bch = CONCEPT_CD,
         RXNORM.umls = RXNORM) %>%
  mutate_all(na_if,"") %>%
  unique()


## note: where does sourcesystem_cd come from" Alba?
```

Visualize differences in mappings
```{r}

test <- compare_mappings_subset %>%
  mutate(all_3_match = (RXNORM.umls == RXNORM.manual) & (RXNORM.manual == RXNORM.mohamad),
         only_UMLS_MANUAL_match = (RXNORM.umls == RXNORM.manual) & (RXNORM.manual != RXNORM.mohamad | is.na(RXNORM.mohamad)),
         only_MANUAL_MOHAMAD_match = (RXNORM.mohamad == RXNORM.manual) & (RXNORM.manual != RXNORM.umls | is.na(RXNORM.umls)),
         only_UMLS_MOHAMAD_match = (RXNORM.mohamad == RXNORM.umls) & (RXNORM.manual != RXNORM.umls | is.na(RXNORM.manual)),
         only_UMLS_available = is.na(RXNORM.manual) & is.na(RXNORM.mohamad),
         only_MANUAL_available = is.na(RXNORM.umls) & is.na(RXNORM.mohamad),
         only_MOHAMAD_available = is.na(RXNORM.manual) & is.na(RXNORM.umls)
  )

print(paste0("Cases where all mappings match RXNORM codes: ", sum(test$all_3_match, na.rm = TRUE)))
print(paste0("Cases where only UMLS and MANUAL mappings match RXNORM codes: ", sum(test$only_UMLS_MANUAL_match, na.rm = TRUE)))
print(paste0("Cases where only MOHAMAD and MANUAL mappings match RXNORM codes: ", sum(test$only_MANUAL_MOHAMAD_match, na.rm = TRUE)))
print(paste0("Cases where only UMLS and MOHAMAD mappings match RXNORM codes: ", sum(test$only_UMLS_MOHAMAD_match, na.rm = TRUE)))
print(paste0("Cases where only UMLS mappings are available: ", sum(test$only_UMLS_available, na.rm = TRUE)))
print(paste0("Cases where only MANUAL mappings are available: ", sum(test$only_MANUAL_available, na.rm = TRUE)))
print(paste0("Cases where only MOHAMAD mappings are available: ", sum(test$only_MOHAMAD_available, na.rm = TRUE)))



```






