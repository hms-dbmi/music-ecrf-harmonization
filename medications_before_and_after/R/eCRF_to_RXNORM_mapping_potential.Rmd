---
title: "Generate Potential eCRF to RXNORM Mapping"
author: "Alba Gutierrez"
date: "6/15/2021"
output: html_document
---

# Load Packages
```{r}
library(dplyr)
library(lubridate)
library(tidyverse)
```

# Load UMLS database subset (all RXNORM codes)
The following SQL was used to generate the subset:
create table ag440_rxnorm as
select CUI,SAB, TTY, CODE, STR from mrconso where sab = 'RXNORM'and lat = 'ENG';

```{r}
rxnorm_subset <- read.delim("../data/rxnorm.dsv")
```

# Load the medication table specifications
The full list with all the medications including code, generic name, class and trades, is obtained from the MUSIC dropbox. The original file is called "CodeListD(Meds) MUSIC 9-7-20". It is a word document that has been transformed into a csv format. 
```{r}
meds_keywords <- read.csv("../data/CodeListD(Meds) MUSIC 9-7-20.csv", colClasses = "character" )
print(length(unique(meds_keywords$Code)))
```

There are 32 medication classes, divided into 349 codes for 325 generic medication names. For each code, for some we have the specific trades (from 1 to 5 distinct trades), and for others we only have the generic name and class. 

We will focus on those medications that we can extract in an automatic way, based on the information we have. We will use as keyword for each medication code, the generic names that are distinct than "Not specified" and distinct than "Other...", and we will use as keywords the generic names and the trades. 
```{r}
meds_auto <- meds_keywords %>%
  dplyr::filter( tolower(Generic.Name) != "not specified" & 
                 ! grepl( "^other",tolower(Generic.Name)))

print(length(unique(meds_auto$Code)))
```
We have 295 medications that we can query in an automatic way. 

# From eCRF to RXNORM
Search through the UMLS subset for the keywords associated with the eCRF terms.
We use as keywords the Trades and the Generic Name for our search.
We are not restricting by TTY in this eCRF.

```{r}

# add keywords to meds_auto df
meds_auto <- meds_auto %>% mutate(key = str_c(Generic.Name, Trade.1, Trade.2, Trade.3, Trade.4, Trade.5, sep = '|'),  # this line combines the generic name with the trade names, separated by |, to form a single keyword
                                  key = str_remove(key, '\\|+$'), # this line removes any trailing pipes from the keyword
                                  key = str_replace_all(key, '\\|{2,}', '\\|'), # this line removes any multiples of pipes (||), which can happen if trades 1 & 3 are listed but not trade 2, for example
                                  key = tolower(key)) # this line converts all keywords to lowercase

# create a blank dataframe for ecrf_to_rxnorm
ecrf_to_rxnorm <- data.frame('ECRF_CODE' = '', 'ECRF_GENERIC_NAME' = '', 'RXNORM_CODE' = '', 'RXNORM_DESCRIPTION' = '')
ecrf_to_rxnorm <- ecrf_to_rxnorm[-1,]

non_mapping_keywords = c()
for( i  in 1:nrow( meds_auto ) ){
  
  rxnorm_output <- rxnorm_subset %>% 
    dplyr::filter( grepl(meds_auto[i, 'key'] , tolower(STR))) %>%       # search for keyword within rxnorm STR (lowercase)  
    dplyr::group_by( CODE ) %>%     # group by code, as some codes are listed multiple times with different TTY or STR
    dplyr::summarise(RXNORM_DESCRIPTION = paste(STR, collapse = ' | ')) %>%   # combining all STRs to retain all information 
    dplyr::mutate( ECRF_CODE = meds_auto[i, 'Code'], 
                   ECRF_GENERIC_NAME = meds_auto[i, 'Generic.Name'], 
                   RXNORM_CODE = as.character( CODE )) %>%
    dplyr::select( ECRF_CODE, ECRF_GENERIC_NAME, RXNORM_CODE, RXNORM_DESCRIPTION)

  # if the keyword matches 1 or more RXNORM entries, add the results to ecrf_to_rxnorm
  if( nrow(rxnorm_output ) > 0){
      ecrf_to_rxnorm <- rbind( ecrf_to_rxnorm, rxnorm_output )
  }
  
  # else, add the keyword to the list of non mapping keywords
  else{ 
    non_mapping_keywords <- c(non_mapping_keywords, meds_auto[i, 'key'])
    print(i)
    print(meds_auto[i, 'key'])
  }
  
}
```

```{r}
print(length(non_mapping_keywords))
print(length(unique(ecrf_to_rxnorm$ECRF_CODE)))
print(length(unique(ecrf_to_rxnorm$RXNORM_CODE)))


```


There are only 30 codes for which we cannot find any RXNORM that matches in UMLS.
We have 265 (89.83%) of medication codes found that mapped to 44,265 RXNORM codes.

# Manual review of medications which did not map to any RXNORM codes
Method:
- google search given generic and trade names to see if there are any typos
- search generic and trade names + 'UMLS' to see if a CUI can be found
- if a CUI is found, search for it in the UMLS database. 
- if an RXNORM is found for the CUI, build keyword around them.
- edit meds_for_manual_keyword_review.csv as necessary and save as meds_for_manual_keyword_review_edited.csv when complete
```{r}
manual_review <- meds_auto %>% filter(key %in% non_mapping_keywords)

write.csv(manual_review,'../data/meds_for_manual_keyword_review.csv')

# the below code was manually run multiple times with various test keywords to determine how best to extract the missing information
#key <- tolower('cytosorb')
#rxnorm_subset %>% 
#    dplyr::filter( grepl(key , tolower(STR)))

# after manual checks, re-load manual review file
manual_review <- read.csv('../data/meds_for_manual_keyword_review_edited.csv') %>% filter(manually_generated_keyword != '')

# re-run RXNORM search for these keywords (filter for those where there is actulaly a manually_generated_keyword supplied)
non_mapping_keywords = c()
for( i  in 1:nrow( manual_review ) ){  
  
  rxnorm_output <- rxnorm_subset %>% 
    dplyr::filter( grepl(manual_review[i, 'manually_generated_keyword'] , tolower(STR))) %>%       # search for keyword within rxnorm STR (lowercase)  
    dplyr::group_by( CODE ) %>%     # group by code, as some codes are listed multiple times with different TTY or STR
    dplyr::summarise(RXNORM_DESCRIPTION = paste(STR, collapse = ' | ')) %>%   # combining all STRs to retain all information 
    dplyr::mutate( ECRF_CODE = manual_review[i, 'Code'], 
                   ECRF_GENERIC_NAME = manual_review[i, 'Generic.Name'], 
                   RXNORM_CODE = as.character( CODE )) %>%
    dplyr::select( ECRF_CODE, ECRF_GENERIC_NAME, RXNORM_CODE, RXNORM_DESCRIPTION)

  # if the keyword matches 1 or more RXNORM entries, add the results to ecrf_to_rxnorm
  if( nrow(rxnorm_output ) > 0){
      ecrf_to_rxnorm <- rbind( ecrf_to_rxnorm, rxnorm_output )
  }
  
  # else, add the keyword to the list of non mapping keywords (there should be none, since all these keywords have been manually reviewed)
  else{ 
    non_mapping_keywords <- c(non_mapping_keywords, manual_review[i, 'manually_generated_keyword'])
    print(i)
    print(meds_auto[i, 'manually_generated_keyword'])
  }
  
}


print(manual_review <- read.csv('../data/meds_for_manual_keyword_review_edited.csv') %>% filter(manually_generated_keyword == '') %>% nrow())
print(length(unique(ecrf_to_rxnorm$ECRF_CODE)))
print(length(unique(ecrf_to_rxnorm$RXNORM_CODE)))

```

Now, there are only 12 codes for which we cannot find any RXNORM that matches in UMLS.
We have 283 (95.83%) of medication codes found that mapped to 45,663 RXNORM codes.

# From RXNORM to BCH
Check which of the RXNORM are present in the BCH internal mapping. 
In the BCH mapping we have 2,196 RXNORM codes that map to 19,141 BCH internal codes.
```{r}
bchmapping <- read.csv("../data/MedicationsMapBCH.csv")
length(unique(bchmapping$ACT_CONCEPT_CD))
length(unique(bchmapping$BCH_CONCEPT_CD))

bchmapping$RXNORM_CODE <- sapply(strsplit( as.character(bchmapping$ACT_CONCEPT_CD), "RXNORM:"), '[', 2)

rxnorm_to_bch <- inner_join( ecrf_to_rxnorm, bchmapping, by="RXNORM_CODE")
length( unique( rxnorm_to_bch$ECRF_CODE))
length( unique( rxnorm_to_bch$RXNORM_CODE))
length( unique( rxnorm_to_bch$BCH_CONCEPT_CD))
```

In the BCH mapping we find 210 eCRF medication codes that map to 574 RXNORM codes and to 6,730 BCH internal codes.


# From BCH mapping to MISC patients
We summarise the information of the codes that are present in the MISC patients. 
```{r}

# add original generic and trade names as a column
meds_auto <- meds_auto %>%
  mutate(ECRF_TRADE_NAMES = str_c(Trade.1, Trade.2, Trade.3, Trade.4, Trade.5, sep = ', '),  # this line combines the trade names, separated by ' ,' so it is more human readable
                                  ECRF_TRADE_NAMES = str_remove(ECRF_TRADE_NAMES, '(, )+$'), # this line removes any trailing commas from the keyword
                                  ECRF_TRADE_NAMES = str_replace_all(ECRF_TRADE_NAMES, '(, ){2,}', '\\|')) # this line removes any multiples of commas, which can happen if trades 1 & 3 are listed but not trade 2, for example

ecrf_to_rxnorm <- left_join(ecrf_to_rxnorm, meds_auto %>% select(Code, ECRF_TRADE_NAMES), by = c('ECRF_CODE' = 'Code'))
rxnorm_to_bch <- inner_join( ecrf_to_rxnorm, bchmapping, by="RXNORM_CODE")

# load MISC patient medication data
misc_meds <- read.delim("../local_ref/music_patients_meds.dsv", sep = ',')

# filter MISC patient medication data to concepts that we have identified as potential matches for the eCRF variables
# filter out duplicated rows
misc_meds <- misc_meds %>% 
  dplyr::filter( CONCEPT_CD %in%  rxnorm_to_bch$BCH_CONCEPT_CD ) %>%
  unique()

# create misc_meds_info, which combines the MISC patient medication data with identified BCH and RXNORM codes for each eCRF variable
misc_meds_info <- misc_meds %>% 
  dplyr::left_join( rxnorm_to_bch, by=c("CONCEPT_CD"="BCH_CONCEPT_CD"))


length(unique(misc_meds_info$ECRF_CODE))
length(unique(misc_meds_info$CONCEPT_CD))
```
We find 122 eCRF medication codes present in the BCH MISC patients. 
We make a summary to see how many MISC patients present each one, and in which date ranges. 

First we add a column based on when the medication was prescribed, during the hospitalization, or before or after. 
```{r}
misc_meds_info$med_date <- sapply(strsplit( as.character(misc_meds_info$START_DATE), "[ ]"), '[', 1)
misc_meds_info$misc_start_date <- sapply(strsplit( as.character(misc_meds_info$ADMISSIONDATE), "[ ]"), '[', 1)
misc_meds_info$misc_end_date <- sapply(strsplit( as.character(misc_meds_info$END_DATE), "[ ]"), '[', 1)
misc_meds_info$when <- ifelse( dmy( misc_meds_info$med_date ) < dmy( misc_meds_info$misc_start_date), "before", ifelse( dmy( misc_meds_info$med_date) > dmy( misc_meds_info$misc_end_date), "after", "during"))
```

As a sanity check, and to better understand the data, we will create two subsets, one with the "during" hospitalization, and one with the "before or after", and we check if for the "during hospitalization all the medications prescribed are "ADMINMED". 

```{r}
misc_meds_info$prefix <- sapply(strsplit( as.character(misc_meds_info$CONCEPT_CD), "[:]"), '[', 1)
during <- misc_meds_info %>%
  dplyr::filter( when == "during")

summary( as.factor( during$prefix))

before_after <- misc_meds_info %>%
  dplyr::filter( when != "during")
summary( as.factor( before_after$prefix))
```

And we create the summary for each medication in our dataset. 
- in this summary table, each row is a unique BCH concept. 
```{r}

# summarise music patient data for each concept
bch_med_concept_summary <- misc_meds_info %>%
  group_by(CONCEPT_CD) %>%
  summarise(min_date = min( dmy( med_date ) ), 
            max_date = max( dmy( med_date ) ),
            distinct_patients = length(unique(PATIENT_NUM)),
            distinct_observations = length(PATIENT_NUM))

# join the summary with eCRF, RXNORM, and BCH code mapping info
bch_med_concept_summary <- left_join(bch_med_concept_summary, rxnorm_to_bch, by = c('CONCEPT_CD' = 'BCH_CONCEPT_CD')) 

# reorganize and rename columns
bch_med_concept_summary <- bch_med_concept_summary %>%
  mutate(eCRF_name = 'medcations_before_and_after') %>%
  rename('BCH_CONCEPT_DESCRIPTION' = 'BCH_NAME_CHAR') %>%
  select(eCRF_name, ECRF_CODE, ECRF_GENERIC_NAME, ECRF_TRADE_NAMES, 
         CONCEPT_CD, BCH_CONCEPT_PATH, BCH_CONCEPT_DESCRIPTION, min_date, max_date, distinct_patients, distinct_observations) %>%
  arrange(ECRF_CODE)


```

- in this summary table, each row is a unique eCRF code. 
```{r}

# summarise music patient data for each code
ecrf_med_concept_summary <- misc_meds_info %>%
  group_by(ECRF_CODE) %>%
  summarise(min_date = min( dmy( med_date ) ), 
            max_date = max( dmy( med_date ) ),
            distinct_patients = length(unique(PATIENT_NUM)),
            distinct_observations = length(PATIENT_NUM),
            distinct_concepts = length(unique(CONCEPT_CD)))

# join the summary with eCRF, RXNORM, and BCH code mapping info
ecrf_med_concept_summary <- left_join(ecrf_med_concept_summary, 
                                      rxnorm_to_bch %>% select(ECRF_CODE, ECRF_GENERIC_NAME, ECRF_TRADE_NAMES) %>% unique(), 
                                      by = 'ECRF_CODE') 

# reorganize and rename columns
ecrf_med_concept_summary <- ecrf_med_concept_summary %>%
  mutate(eCRF_name = 'medications_before_and_after_hosp') %>%
  select(eCRF_name, ECRF_CODE, ECRF_GENERIC_NAME, ECRF_TRADE_NAMES,
         min_date, max_date, distinct_patients, distinct_observations, distinct_concepts) %>%
  arrange(ECRF_CODE)


```

# Save the output summary

```{r}
write.csv(bch_med_concept_summary, '../data/bch_med_concept_summary_toReview.csv', row.names = FALSE)
write.csv(ecrf_med_concept_summary, '../data/ecrf_med_concept_summary_toReview.csv', row.names = FALSE)
```

