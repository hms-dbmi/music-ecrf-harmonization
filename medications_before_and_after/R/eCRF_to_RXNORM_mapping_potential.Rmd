---
title: "Generate Potential eCRF to RXNORM Mapping"
author: "Alba Gutierrez"
date: "07/01/2021"
output: html_document
---

# Load Packages
```{r}
library(dplyr)
library(lubridate)
library(tidyverse)
```

# Load UMLS database subset (all RXNORM codes)
The following SQL was used to generate the subset:
create table ag440_rxnorm as
select CUI,SAB, TTY, CODE, STR from mrconso where sab = 'RXNORM'and lat = 'ENG';

```{r}
rxnorm_subset <- read.delim("../data/rxnorm.dsv")
```

# Load the medication table specifications
The full list with all the medications including code, generic name, class and trades, is obtained from the MUSIC dropbox. The original file is called "CodeListD(Meds) MUSIC 9-7-20". It is a word document that has been transformed into a csv format. 
```{r}
meds_keywords <- read.csv("../data/CodeListD(Meds) MUSIC 9-7-20.csv", colClasses = "character" )
print(length(unique(meds_keywords$Code)))
```

There are 32 medication classes, divided into 349 codes for 325 generic medication names. For each code, for some we have the specific trades (from 1 to 5 distinct trades), and for others we only have the generic name and class. 

We will focus on those medications that we can extract in an automatic way, based on the information we have. We will use as keyword for each medication code, the generic names that are distinct than "Not specified" and distinct than "Other...", and we will use as keywords the generic names and the trades. 
```{r}
meds_auto <- meds_keywords %>%
  dplyr::filter( tolower(Generic.Name) != "not specified" & 
                 ! grepl( "^other",tolower(Generic.Name)))

print(length(unique(meds_auto$Code)))
```
We have 295 medications that we can query in an automatic way. 

# From eCRF to RXNORM
Search through the UMLS subset for the keywords associated with the eCRF terms.
We use as keywords the Trades and the Generic Name for our search.
We are not restricting by TTY in this eCRF.

```{r}

# add keywords to meds_auto df
meds_auto <- meds_auto %>% mutate(key = str_c(Generic.Name, Trade.1, Trade.2, Trade.3, Trade.4, Trade.5, sep = '|'),  # this line combines the generic name with the trade names, separated by |, to form a single keyword
                                  key = str_remove(key, '\\|+$'), # this line removes any trailing pipes from the keyword
                                  key = str_replace_all(key, '\\|{2,}', '\\|'), # this line removes any multiples of pipes (||), which can happen if trades 1 & 3 are listed but not trade 2, for example
                                  key = tolower(key)) # this line converts all keywords to lowercase

# add manually generated keywords
# these have been refined through the eCRF_to_RXNORM_mapping_potential_exploration.Rmd notebook
# view meds_for_manual_keyword_review_edited.csv for more details
manual_keywords <- read_csv('../data/manual_keywords_eCRF_to_RXNORM.csv')
meds_auto[meds_auto$Code %in% manual_keywords$Code,c('Code', 'key')] <- manual_keywords[,c('Code', 'key')]

# create a blank dataframe for ecrf_to_rxnorm
ecrf_to_rxnorm <- data.frame('ECRF_CODE' = '', 'ECRF_GENERIC_NAME' = '', 'RXNORM_CODE' = '', 'RXNORM_DESCRIPTION' = '')
ecrf_to_rxnorm <- ecrf_to_rxnorm[-1,]

non_mapping_keywords = c()
for( i  in 1:nrow( meds_auto ) ){
  
  rxnorm_output <- rxnorm_subset %>% 
    dplyr::filter( grepl(meds_auto[i, 'key'] , tolower(STR))) %>%       # search for keyword within rxnorm STR (lowercase)  
    dplyr::group_by( CODE ) %>%     # group by code, as some codes are listed multiple times with different TTY or STR
    dplyr::summarise(RXNORM_DESCRIPTION = paste(STR, collapse = ' | ')) %>%   # combining all STRs to retain all information 
    dplyr::mutate( ECRF_CODE = meds_auto[i, 'Code'], 
                   ECRF_GENERIC_NAME = meds_auto[i, 'Generic.Name'], 
                   RXNORM_CODE = as.character( CODE )) %>%
    dplyr::select( ECRF_CODE, ECRF_GENERIC_NAME, RXNORM_CODE, RXNORM_DESCRIPTION)

  # if the keyword matches 1 or more RXNORM entries, add the results to ecrf_to_rxnorm
  if( nrow(rxnorm_output ) > 0){
      ecrf_to_rxnorm <- rbind( ecrf_to_rxnorm, rxnorm_output )
  }
  
  # else, add the keyword to the list of non mapping keywords
  else{ 
    non_mapping_keywords <- c(non_mapping_keywords, meds_auto[i, 'key'])
    print(i)
    print(meds_auto[i, 'key'])
  }
  
}
```

```{r}
print(length(non_mapping_keywords))
print(length(unique(ecrf_to_rxnorm$ECRF_CODE)))
print(length(unique(ecrf_to_rxnorm$RXNORM_CODE)))


```


There are only 13 codes for which we cannot find any RXNORM that matches in UMLS.
We have 282 (95/59%) of medication codes found that mapped to 45,010 RXNORM codes.

# From RXNORM to BCH
Check which of the RXNORM are present in the BCH internal mapping. 
In the BCH mapping we have 2,196 RXNORM codes that map to 19,141 BCH internal codes.
```{r}
bchmapping <- read.csv("../data/MedicationsMapBCH.csv")
length(unique(bchmapping$ACT_CONCEPT_CD))
length(unique(bchmapping$BCH_CONCEPT_CD))

bchmapping$RXNORM_CODE <- sapply(strsplit( as.character(bchmapping$ACT_CONCEPT_CD), "RXNORM:"), '[', 2)

rxnorm_to_bch <- inner_join( ecrf_to_rxnorm, bchmapping, by="RXNORM_CODE")
length( unique( rxnorm_to_bch$ECRF_CODE))
length( unique( rxnorm_to_bch$RXNORM_CODE))
length( unique( rxnorm_to_bch$BCH_CONCEPT_CD))
```

In the BCH mapping we find 210 eCRF medication codes that map to 560 RXNORM codes and to 6,564 BCH internal codes.


# From BCH mapping to MISC patients
We summarise the information of the codes that are present in the MISC patients. 
```{r}

# add original generic and trade names as a column
meds_auto <- meds_auto %>%
  mutate(ECRF_TRADE_NAMES = str_c(Trade.1, Trade.2, Trade.3, Trade.4, Trade.5, sep = ', '),  # this line combines the trade names, separated by ' ,' so it is more human readable
                                  ECRF_TRADE_NAMES = str_remove(ECRF_TRADE_NAMES, '(, )+$'), # this line removes any trailing commas from the keyword
                                  ECRF_TRADE_NAMES = str_replace_all(ECRF_TRADE_NAMES, '(, ){2,}', '\\|')) # this line removes any multiples of commas, which can happen if trades 1 & 3 are listed but not trade 2, for example

ecrf_to_rxnorm <- left_join(ecrf_to_rxnorm, meds_auto %>% select(Code, ECRF_TRADE_NAMES), by = c('ECRF_CODE' = 'Code'))
rxnorm_to_bch <- inner_join( ecrf_to_rxnorm, bchmapping, by="RXNORM_CODE")

# load MISC patient medication data
misc_meds <- read.delim("../local_ref/music_patients_meds.dsv", sep = ',')

# filter MISC patient medication data to concepts that we have identified as potential matches for the eCRF variables
# filter out duplicated rows
misc_meds <- misc_meds %>% 
  dplyr::filter( CONCEPT_CD %in%  rxnorm_to_bch$BCH_CONCEPT_CD ) %>%
  unique()

# create misc_meds_info, which combines the MISC patient medication data with identified BCH and RXNORM codes for each eCRF variable
misc_meds_info <- misc_meds %>% 
  dplyr::left_join( rxnorm_to_bch, by=c("CONCEPT_CD"="BCH_CONCEPT_CD"))


length(unique(misc_meds_info$ECRF_CODE))
length(unique(misc_meds_info$CONCEPT_CD))
```
We find 122 eCRF medication codes present in the BCH MISC patients. 
We make a summary to see how many MISC patients present each one, and in which date ranges. 

First we add a column based on when the medication was prescribed, during the hospitalization, or before or after. 
```{r}
misc_meds_info$med_date <- sapply(strsplit( as.character(misc_meds_info$START_DATE), "[ ]"), '[', 1)
misc_meds_info$misc_start_date <- sapply(strsplit( as.character(misc_meds_info$ADMISSIONDATE), "[ ]"), '[', 1)
misc_meds_info$misc_end_date <- sapply(strsplit( as.character(misc_meds_info$END_DATE), "[ ]"), '[', 1)
misc_meds_info$when <- ifelse( dmy( misc_meds_info$med_date ) < dmy( misc_meds_info$misc_start_date), "before", ifelse( dmy( misc_meds_info$med_date) > dmy( misc_meds_info$misc_end_date), "after", "during"))
```

As a sanity check, and to better understand the data, we will create two subsets, one with the "during" hospitalization, and one with the "before or after", and we check if for the "during hospitalization all the medications prescribed are "ADMINMED". 

```{r}
misc_meds_info$prefix <- sapply(strsplit( as.character(misc_meds_info$CONCEPT_CD), "[:]"), '[', 1)
during <- misc_meds_info %>%
  dplyr::filter( when == "during")

summary( as.factor( during$prefix))

before_after <- misc_meds_info %>%
  dplyr::filter( when != "during")
summary( as.factor( before_after$prefix))
```

And we create the summary for each medication in our dataset. 
- in this summary table, each row is a unique BCH concept. 
```{r}

# function for returning RXNORM codes list
# return the list of relevant RXNORM codes; if the list is greater than 5, return 'greater than 5 RXNORM codes mapped'
return_rxnorm_code <- function(RXNORM_CODES) {
  if (length(unique(RXNORM_CODES)) > 5) {
    return('greater than 5 RXNORM codes mapped to BCH code') 
  } else {
    return(paste(unique(RXNORM_CODES), collapse = ', '))
  }
}

return_rxnorm_desc <- function(RXNORM_DESCRIPTIONS) {
  if (length(unique(RXNORM_DESCRIPTIONS)) > 5) {
    return('greater than 5 RXNORM codes mapped to BCH code') 
  } else {
    return(paste(unique(RXNORM_DESCRIPTIONS), collapse = ', '))
  }
}

# summarize music patient data for each concept
bch_med_concept_summary <- misc_meds_info %>% 
  group_by(CONCEPT_CD, BCH_CONCEPT_PATH, BCH_NAME_CHAR) %>%
  summarise(ECRF_CODE = ECRF_CODE,
            ECRF_GENERIC_NAME = ECRF_GENERIC_NAME,
            ECRF_TRADE_NAMES = ECRF_TRADE_NAMES,
            RXNORM_CODES = return_rxnorm_code(RXNORM_CODE),
            RXNORM_DESCS = return_rxnorm_desc(RXNORM_DESCRIPTION),
            min_date = min( dmy( med_date ) ), 
            max_date = max( dmy( med_date ) ),
            distinct_patients = length(unique(PATIENT_NUM)),
            distinct_observations = length(PATIENT_NUM))


# reorganize and rename columns
bch_med_concept_summary <- bch_med_concept_summary %>%
  mutate(eCRF_name = 'medcations_before_and_after') %>%
  rename('BCH_CONCEPT_DESCRIPTION' = 'BCH_NAME_CHAR') %>%
  select(eCRF_name, ECRF_CODE, ECRF_GENERIC_NAME, ECRF_TRADE_NAMES, 
         RXNORM_CODES, RXNORM_DESCS,
         CONCEPT_CD, BCH_CONCEPT_PATH, BCH_CONCEPT_DESCRIPTION, min_date, max_date, distinct_patients, distinct_observations) %>%
  arrange(ECRF_CODE) %>%
  unique() # there are still some duplicated rows ....


```

- in this summary table, each row is a unique eCRF code. 
```{r}

# summarise music patient data for each code
ecrf_med_concept_summary <- misc_meds_info %>%
  group_by(ECRF_CODE) %>%
  summarise(min_date = min( dmy( med_date ) ), 
            max_date = max( dmy( med_date ) ),
            distinct_patients = length(unique(PATIENT_NUM)),
            distinct_observations = length(PATIENT_NUM),
            distinct_concepts = length(unique(CONCEPT_CD)))

# join the summary with eCRF, RXNORM, and BCH code mapping info
ecrf_med_concept_summary <- left_join(ecrf_med_concept_summary, 
                                      rxnorm_to_bch %>% select(ECRF_CODE, ECRF_GENERIC_NAME, ECRF_TRADE_NAMES) %>% unique(), 
                                      by = 'ECRF_CODE') 

# reorganize and rename columns
ecrf_med_concept_summary <- ecrf_med_concept_summary %>%
  mutate(eCRF_name = 'medications_before_and_after_hosp') %>%
  select(eCRF_name, ECRF_CODE, ECRF_GENERIC_NAME, ECRF_TRADE_NAMES,
         min_date, max_date, distinct_patients, distinct_observations, distinct_concepts) %>%
  arrange(ECRF_CODE)

# add the ecrf codes for which we have no information 
meds_missing <- meds_auto %>%
  dplyr::filter( ! Code %in% ecrf_med_concept_summary$ECRF_CODE) %>%
  dplyr::mutate( eCRF_name = "medications_before_and_after_hosp", 
                 ECRF_CODE = Code, 
                 ECRF_GENERIC_NAME = Generic.Name) %>%
  dplyr::select( eCRF_name, ECRF_CODE, ECRF_GENERIC_NAME, ECRF_TRADE_NAMES)

# add the missing codes at the end of ecrf_med_concept_summary
ecrf_med_concept_summary <- rbindlist( list( ecrf_med_concept_summary, meds_missing), fill = TRUE )
```

# Save the output summary

```{r}
write.csv(ecrf_med_concept_summary, '../data/ecrf_med_concept_summary_toReview.csv', row.names = FALSE)
```

# Check the output summary
We know the BCH to RXNORM mapping is not perfect. 
Are there any BCH internal database codes which appear to map to an abnormally high number of eCRF codes?
```{r}
bch_med_concept_summary %>%
  ungroup %>%
  group_by(CONCEPT_CD) %>%
  summarise(BCH_CONCEPT_PATH = first(BCH_CONCEPT_PATH),
            BCH_CONCEPT_DESCRIPTION = first(BCH_CONCEPT_DESCRIPTION),
            n_eCRF_mappings = n_distinct(ECRF_CODE),) %>%
  arrange(desc(n_eCRF_mappings))

```
We can see that 100 eCRF codes (almost 1/3 of them!) have been assigned the general BCH internal concept code of 'ADMINMED:2799024'. This appears to represent non-categorized administered medicines, in this case Sodium Chloride 0.9%. This general concept code is not an accurate mapping and should be removed. As a sanity check, let's look at the eCRF descriptions of the codes which map to this 'Sodium Chloride 0.9%' code. 

```{r}
bch_med_concept_summary %>% filter(CONCEPT_CD == 'ADMINMED:2799024')

```
Medications such as Adenosine, Lidocaine, Ampicilin, etc. should not map to Sodium Chloridee 0.9%... we will remove this BCH concept code from our mapping and summary table.

```{r}
bch_med_concept_summary <- bch_med_concept_summary %>% filter(CONCEPT_CD != 'ADMINMED:2799024')

```

The next most prevalent BCH code is 'ADMINMED:2798992', which maps to 64 eCRF codes and is described in the BCH mapping as "Dextrose 5% in Water". The BCH concept path also reveals that it is categorized as a  non categorized administered medication. 

Looking at which eCRF variables map to this code also suggests that this is not a useful mapping. We will remove this code from the mapping and summary table. 
```{r}
bch_med_concept_summary %>% filter(CONCEPT_CD == 'ADMINMED:2798992')
bch_med_concept_summary <- bch_med_concept_summary %>% filter(CONCEPT_CD != 'ADMINMED:2798992')

```

The next most prevalent BCH code is 'ADMINMED:2797919', which maps to 16 eCRF codes and is described in the BCH mapping as 'heparin'. 
```{r}
bch_med_concept_summary %>% filter(CONCEPT_CD == 'ADMINMED:2797919')


```
There is a specific eCRF code that corresponds to Heparin (07.08). We will keep this mapping, and remove the mapping from the BCH heparin code to all other eCRF codes.
```{r}
bch_med_concept_summary <- bch_med_concept_summary %>% filter(CONCEPT_CD != 'ADMINMED:2797919' | ECRF_CODE == '07.08')


```

We can repeat this process for other repetitive, general codes.

Save the updated bch_med_concept_summary.
```{r}
write.csv(bch_med_concept_summary, '../data/bch_med_concept_summary_toReview.csv', row.names = FALSE)


```
